ğŸ“Œ Ã‰tapes du projet :
1. Analyse du sujet et des contraintes

    Lire en dÃ©tail le sujet pour comprendre les attentes.
    Lister les interdictions (fork(), utilisation de bibliothÃ¨ques externes, C++ moderne, etc.).
    Identifier les fonctionnalitÃ©s obligatoires et les bonus.

2. DÃ©finition de lâ€™architecture du projet

    CrÃ©ation de la structure des fichiers (arborescence).
    DÃ©coupage du projet en modules (gestion des connexions, parsing, commandes IRC, etc.).
    DÃ©finition des classes principales et des interactions entre elles.

3. Gestion des connexions rÃ©seau

    Utilisation des sockets et des appels systÃ¨mes autorisÃ©s (socket(), bind(), listen(), accept(), send(), recv(), etc.).
    ImplÃ©mentation de poll() (ou Ã©quivalent) pour gÃ©rer plusieurs clients sans bloquer.
    Gestion des erreurs et des connexions simultanÃ©es.

4. ImplÃ©mentation du protocole IRC

    Authentification (PASS, NICK, USER).
    Gestion des channels (JOIN, PART, TOPIC, MODE).
    Messagerie (PRIVMSG, NOTICE).
    Commandes opÃ©rateurs (KICK, INVITE, MODE).

5. Gestion des messages et des clients

    Stockage des clients et des channels.
    Distribution des messages aux bons destinataires.
    VÃ©rification de la conformitÃ© aux standards IRC.

6. SÃ©curisation et gestion des erreurs

    DÃ©tection des connexions invalides et des messages malformÃ©s.
    Gestion des dÃ©connexions propres.
    SÃ©curisation des accÃ¨s (mot de passe serveur).

7. Tests et validation

    Test du serveur avec un client IRC officiel (par ex. WeeChat, HexChat).
    VÃ©rification du bon fonctionnement des commandes.
    Simulation de cas limites (ex. connexions multiples, envoi de messages rapides).

8. Optimisation et nettoyage du code

    Respect des normes C++98.
    Ajout de commentaires et organisation du code.
    Nettoyage des ressources pour Ã©viter les fuites mÃ©moire.

9. RÃ©daction du Makefile et finalisation

    CrÃ©ation du Makefile avec les rÃ¨gles : all, clean, fclean, re.
    VÃ©rification que tout compile sans erreur (-Wall -Wextra -Werror).
    Derniers tests avant rendu.



<------------------------------------------------------------------------------------------------------------->

Details des fichiers :

1ï¸âƒ£ Channel.cpp (Gestion des salons IRC)

ğŸ“Œ Ce fichier contiendra toute la logique liÃ©e aux salons (channels) du serveur IRC.
ğŸ”¹ Ce qu'il va gÃ©rer :

âœ… CrÃ©ation et suppression des salons
âœ… Gestion des utilisateurs dans un salon
âœ… Gestion des modes des salons (i, t, k, o, l)
âœ… Gestion des messages envoyÃ©s aux membres du salon
ğŸ”¹ Fonctions principales :

    Channel(std::string name) â†’ Constructeur qui crÃ©e un channel.
    void addClient(Client *client) â†’ Ajoute un client au channel.
    void removeClient(Client *client) â†’ Supprime un client du channel.
    void broadcastMessage(Client *sender, std::string message) â†’ Envoie un message Ã  tous les membres.
    void setTopic(std::string topic) â†’ DÃ©finit le sujet du channel.
    void setMode(char mode, bool enable) â†’ Active/dÃ©sactive un mode du channel.

2ï¸âƒ£ Client.cpp (Gestion des utilisateurs)

ğŸ“Œ Ce fichier gÃ¨re tout ce qui concerne les clients (utilisateurs connectÃ©s).
ğŸ”¹ Ce qu'il va gÃ©rer :

âœ… Stockage des informations des clients
âœ… Authentification et vÃ©rification de l'Ã©tat du client
âœ… Gestion des pseudos et des informations utilisateur
âœ… Gestion des permissions
ğŸ”¹ Fonctions principales :

    Client(int socketFd) â†’ Constructeur du client avec son socket.
    void setNickname(std::string nickname) â†’ DÃ©finit le pseudo du client.
    void setUsername(std::string username) â†’ DÃ©finit le nom d'utilisateur du client.
    void setRealname(std::string realname) â†’ DÃ©finit le real name du client.
    void authenticate() â†’ Marque le client comme authentifiÃ©.
    bool isAuthenticated() const â†’ VÃ©rifie si le client est authentifiÃ©.

3ï¸âƒ£ CommandHandler.cpp (Traitement des commandes IRC)

ğŸ“Œ Ce fichier est responsable de lâ€™interprÃ©tation et du traitement des commandes IRC envoyÃ©es par les clients.
ğŸ”¹ Ce qu'il va gÃ©rer :

âœ… Parser les commandes envoyÃ©es par les clients
âœ… Appeler la bonne fonction en fonction de la commande reÃ§ue
âœ… GÃ©rer les erreurs de syntaxe et de permissions
ğŸ”¹ Fonctions principales :

    void handleCommand(Client *client, std::string command) â†’ DÃ©code et traite la commande IRC.
    void handlePass(Client *client, std::string password) â†’ VÃ©rifie le mot de passe.
    void handleNick(Client *client, std::string nickname) â†’ Change le pseudo.
    void handleUser(Client *client, std::string username, std::string realname) â†’ DÃ©finit l'utilisateur.
    void handleJoin(Client *client, std::string channelName) â†’ Permet au client de rejoindre un salon.
    void handlePart(Client *client, std::string channelName) â†’ Permet au client de quitter un salon.
    void handlePrivMsg(Client *client, std::string target, std::string message) â†’ Envoie un message privÃ©.

4ï¸âƒ£ Server.cpp (Gestion du serveur et des connexions)

ğŸ“Œ Ce fichier gÃ¨re tout ce qui concerne les sockets et les connexions des clients.
ğŸ”¹ Ce qu'il va gÃ©rer :

âœ… CrÃ©ation et Ã©coute du socket serveur
âœ… Gestion des connexions clients avec poll()
âœ… RÃ©ception et envoi des messages des clients
âœ… Suppression propre des clients dÃ©connectÃ©s
ğŸ”¹ Fonctions principales :

    Server(int port, std::string password) â†’ Constructeur qui initialise le serveur.
    void run() â†’ Boucle principale qui Ã©coute les clients et traite leurs commandes.
    void handleNewConnection() â†’ Accepte une nouvelle connexion.
    void handleClientMessage(int clientSocket) â†’ ReÃ§oit et traite un message dâ€™un client.
    void removeClient(int clientSocket) â†’ Supprime un client dÃ©connectÃ©.
    void sendMessage(int clientSocket, std::string message) â†’ Envoie un message Ã  un client.

5ï¸âƒ£ Utils.cpp (Fonctions utilitaires)

ğŸ“Œ Ce fichier contiendra des fonctions gÃ©nÃ©rales rÃ©utilisables dans tout le projet.
ğŸ”¹ Ce qu'il va gÃ©rer :

âœ… Parsing et gestion des chaÃ®nes de caractÃ¨res
âœ… VÃ©rifications et validations des commandes IRC
âœ… Gestion des erreurs
ğŸ”¹ Fonctions principales :

    std::vector<std::string> splitString(std::string input, char delimiter) â†’ DÃ©coupe une chaÃ®ne en fonction d'un sÃ©parateur.
    bool isValidNickname(std::string nickname) â†’ VÃ©rifie si un pseudo est valide.
    std::string toUpperCase(std::string input) â†’ Convertit une chaÃ®ne en majuscules.
    bool isChannelNameValid(std::string name) â†’ VÃ©rifie si un nom de channel respecte les rÃ¨gles IRC.


ğŸ“Œ RÃ©sumÃ© global

Channel.cpp             Gestion des salons IRC (JOIN, PART, TOPIC)
Client.cpp	            Gestion des clients (authentification, pseudo)
CommandHandler.cpp	    InterprÃ©tation des commandes IRC
Server.cpp	            Gestion du serveur et des connexions rÃ©seau
Utils.cpp	            Fonctions utilitaires (parsing, validation)


<------------------------------------------------------------------------------------------------------------->


ğŸ“Œ RÃ©capitulatif et Plan dâ€™Action (07/03/2025)

Nous avons bien avancÃ© sur la gestion des connexions et de l'authentification. Il reste encore plusieurs Ã©tapes pour finaliser le projet IRC. Voici un plan dÃ©taillÃ© des prochaines tÃ¢ches Ã  accomplir :
âœ… 1. Correction du Segfault aprÃ¨s une erreur de mot de passe (ğŸ”´ PRIORITÃ‰)

ğŸ“Œ ProblÃ¨me actuel : Lorsquâ€™un client saisit un mauvais mot de passe, il est dÃ©connectÃ©, mais un segmentation fault survient ensuite.

ğŸ“Œ Action Ã  faire (Prochain objectif) :

    [ğŸ”´ PRIORITAIRE] Trouver la cause du segfault (probablement un accÃ¨s mÃ©moire Ã  un client supprimÃ©).
    VÃ©rifier avec gdb oÃ¹ Ã§a plante exactement :

    gdb ./irc
    run 6667 mypassword

    Puis se connecter avec nc et tester une mauvaise saisie de mot de passe.


â¡ But : Faire fonctionner la reconnexion aprÃ¨s une erreur de mot de passe sans crash.
âœ… 2. ImplÃ©mentation des commandes IRC de base

AprÃ¨s avoir stabilisÃ© la connexion et lâ€™authentification, on doit ajouter les commandes IRC essentielles :
ğŸ”¹ Commandes Ã  implÃ©menter :

    PING/PONG (ğŸ”´ Important pour Ã©viter la dÃ©connexion du client)
        ğŸ“Œ VÃ©rifier si le serveur rÃ©pond correctement au PING.
        ğŸ“Œ Envoyer un PONG en rÃ©ponse.

    PRIVMSG (ğŸ“© Messages privÃ©s entre clients)
        ğŸ“Œ Un client doit pouvoir envoyer un message privÃ© Ã  un autre.
        ğŸ“Œ VÃ©rifier que lâ€™utilisateur destinataire existe avant dâ€™envoyer.

    JOIN / PART (ğŸ“¢ Gestion des canaux)
        ğŸ“Œ Permettre aux clients de rejoindre et quitter un canal.
        ğŸ“Œ CrÃ©er un canal sâ€™il nâ€™existe pas encore.

    LIST (ğŸ“‹ Afficher les canaux disponibles)
        ğŸ“Œ Afficher la liste des salons existants.

    NAMES (ğŸ‘¥ Voir les membres dâ€™un canal)
        ğŸ“Œ Afficher les utilisateurs connectÃ©s sur un canal.


â¡ But : Avoir une premiÃ¨re version fonctionnelle des commandes de base.
âœ… 3. Gestion complÃ¨te des canaux

Une fois que les commandes de base fonctionnent, on doit gÃ©rer correctement les canaux.
ğŸ”¹ FonctionnalitÃ©s Ã  ajouter :

    CrÃ©ation et suppression de canaux
        ğŸ“Œ Si un utilisateur JOIN un canal qui nâ€™existe pas, il est crÃ©Ã©.
        ğŸ“Œ Si le dernier utilisateur PART, le canal est supprimÃ©.

    Gestion des permissions
        ğŸ“Œ Lâ€™utilisateur qui crÃ©e un canal devient opÃ©rateur (@).
        ğŸ“Œ Seuls les opÃ©rateurs peuvent kicker (KICK) et ban (BAN).

    Modes de canal
        ğŸ“Œ ImplÃ©menter les modes de canal (+i, +t, +m, etc.).
        ğŸ“Œ Exemple : +i (invite only), +m (modÃ©rÃ©).


â¡ But : Avoir une gestion basique des canaux fonctionnelle.
âœ… 4. Tests AutomatisÃ©s et DÃ©bogage

    Ajout de scripts de test automatique (tests/)
        ğŸ“Œ Un script doit tester la connexion, lâ€™authentification, lâ€™envoi de messages, la crÃ©ation de canaux, etc.
        ğŸ“Œ Tester chaque commande IRC implÃ©mentÃ©e.

    Utilisation de valgrind pour dÃ©tecter les erreurs mÃ©moire

valgrind --leak-check=full --show-leak-kinds=all ./irc 6667 mypassword

    ğŸ“Œ VÃ©rifier les fuites mÃ©moire et les accÃ¨s Ã  des zones non allouÃ©es.